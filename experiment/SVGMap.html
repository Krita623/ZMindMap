<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D3</title>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script src="./data.js"></script>
  <script src="./clauster.js"></script>
  <script src="./TreeData.js"></script>
  <style>
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    html {
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .svg {
      position: relative;
      width: 100%;
      height: 100%;
      background-color: #eeeef3;
    }

    .asstSvg {}
  </style>
</head>

<body>
  <svg class="svg" id="svg"></svg>
  <svg class="asstSvg"></svg>
  <script>
    let W = window.innerWidth
    let H = window.innerHeight
    const svgEle = document.getElementById('svg')
    const svg = d3.select(svgEle)


    let marge = { top: 10, bottom: 0, left: 10, right: 0 }
    let g = svg.append("g")
      .attr("transform", "translate(" + marge.top + "," + marge.left + ")")
      .attr('id', 'glem');

    const gEle = document.getElementsByClassName('glem')

    //创建一个hierarchy layout
    const hierarchyData = d3.hierarchy(dataset).sum(d => d.value)

    const asstSvg = d3.select('.asstSvg')
    const creator = new TreeDataCreater({ measureSelection: asstSvg })
    const treeData = creator.create(hierarchyData)

    // //创建一个树状图
    // const tree = cluster().size([W - 200, H - 200]).separation(function (a, b) {
    //   // return (a.parent == b.parent ? 1 : 2) / a.depth;
    //   return 20;
    // })

    // //初始化树状图，也就是传入数据,并得到绘制树基本数据
    // const treeData = tree(hierarchyData)
    // console.log(treeData)

    //得到节点
    const nodes = treeData.descendants()
    const links = treeData.links()

    //创建一个贝塞尔生成曲线生成器
    const Bézier_curve_generator = d3.linkHorizontal()
      .x(function (d) { return d.x; })
      .y(function (d) { return d.y; });

    //有了节点和边集的数据后，我们就可以开始绘制了，
    //绘制边
    g.append("g")
      .selectAll("path")
      .data(links)
      .enter()
      .append("path")
      .attr("d", d => {
        const { x, y, width } = d.source
        const start = { x: x + width, y }
        const end = { x: d.target.x, y: d.target.y }

        const bottom_line = `M${x} ${y}L${start.x} ${y}`
        let bottom_line_leaf = ''
        const bezier_line = Bézier_curve_generator({ source: start, target: end })
        if (!d.target.children) {
          bottom_line_leaf = `M${end.x} ${end.y}L${end.x + d.target.width} ${end.y}`
        }
        return `${bottom_line}${bezier_line}${bottom_line_leaf}`
      })
      .attr("fill", "none")
      .attr("stroke", "black")
      .attr("stroke-width", 2)
    //绘制节点和文字
    //老规矩，先创建用以绘制每个节点和对应文字的分组<g>
    const gs = g.append("g")
      .selectAll("g")
      .data(nodes)
      .enter()
      .append("g")
      .attr("transform", function (d) {
        var cx = d.x;
        var cy = d.y - d.height - 4;
        return "translate(" + cx + "," + cy + ")";
      });

    const getTspanData = d => {
      const multiline = creator.getMultiline(d.data.name)
      const height = d.height / multiline.length
      return multiline.map((name) => ({ name, height }))
    }
    //文字
    const tspan = gs.append("text")
      .attr('class', 'text')
      .selectAll('tspan').data(getTspanData).enter().append('tspan')
      .attr('alignment-baseline', 'text-before-edge')
      .text((d) => d.name || ' ')
      .attr('x', 0)
      // .attr('y', 0)
      .attr('dy', (d, i) => i ? d.height : 0)

    const zoom = d3.zoom().on('zoom', () => {
      g.attr("transform", d3.event.transform)
    }).scaleExtent([0.1, 4])

    zoom(svg)
    svg.on('dblclick.zoom', null)

    const fitView = () => {
      const gBB = document.getElementById('glem').getBBox()
      const svgBCR = document.getElementById('svg').getBoundingClientRect()

      const multiple = Math.min(svgBCR.width / (gBB.width + 20), svgBCR.height / (gBB.height + 20))
      const svgCenter = { x: svgBCR.width / 2, y: svgBCR.height / 2 }
      // after scale
      const gCenter = { x: gBB.width * multiple / 2, y: gBB.height * multiple / 2 }
      const center = d3.zoomIdentity.translate(
        -gBB.x * multiple + svgCenter.x - gCenter.x,
        -gBB.y * multiple + svgCenter.y - gCenter.y
      ).scale(multiple)
      // svg.call(zoom.transform, center)
      svg.transition().duration(1000).call(zoom.transform, center)
    }
    fitView()

  </script>
</body>

</html>